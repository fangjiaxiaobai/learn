task helloword << {
	println "hello gradle"
}

task upper << {
	String expStr = "fangxiaobai learn gradle "
	println "original: "+expStr
	println "upper Case: "+expStr.toUpperCase()
}

task count << {
	4.times{
		println "$it "
	}
}

task groovyJDKMethod << {
	String myName = "fangjiaxiaobai";
	myName.each(){
		println "${it}"
	};
}

task hello << {
	println 'hello world!'
}

task intro(dependsOn: hello) << {
	println "I'm Gradle"
}

task hello2 << {
println hello.name
println project.hello.name
println tasks.hello.name
println tasks['hello'].name
}

// 向任务添加依赖关系
// 要将一个任务依赖于另一个任务，这意味着当一个任务完成时，另一个任务将开始。
// 每个任务都使用任务名称进行区分。 任务名称集合由其任务集合引用。 
// 要引用另一个项目中的任务，应该使用项目路径作为相应任务名称的前缀。

task taskY << {
	println 'taskY'
}

task taskX << {
	println 'taskX'
}

taskY.dependsOn taskX

/*
还有另一种方法来添加任务依赖，它就是通过使用闭包。
在这种情况下，任务通过闭包释放如果您在构建脚本中使用闭包，
那么应该返回任务对象的单个任务或集合。
以下示例将任务中从taskX添加依赖项到项目中的所有任务，其名称以“lib”开头。
*/
task taskF << {
	println 'taskF'
}

taskF.dependsOn {
	tasks.findAll{
		task -> task.name.startsWith('lib')
	}
}

task lib1 << {
	println 'lib1'
}

task lib2 << {
	println 'lib2'
}

task notAlib << {
	println 'not a lib'
}

/*
如果用于跳过任务的逻辑不能用谓词表示，则可以使用StopExecutionException。 
如果操作抛出此异常，则会跳过此操作的进一步执行以及此任务的任何后续操作的执行。 
构建继续执行下一个任务
*/

task compile << {
    println 'We are doing the compile.'
}

compile.doFirst {
    // Here you would put arbitrary conditions in real life.
    // But this is used in an integration test so we want defined behavior.
    if (true) { throw new StopExecutionException() }
}
task myTask(dependsOn: 'compile') << {
   println 'I am not affected'
}

/*
Gradle在处理任务时有不同的阶段。 
首先，有一个配置阶段，其中直接在任务的闭包中指定的代码被执行。 
针对每个可用任务执行配置块，而不仅针对稍后实际执行的那些任务。
*/
