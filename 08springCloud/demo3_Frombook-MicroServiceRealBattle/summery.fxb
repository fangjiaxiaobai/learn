之前跟别人的博客大体上学习了SpringCloud微服务，遇到了中间件和docker相关的瓶颈。
现在跟从一本书来重新学习一个SpringCloud
目标是：
    跟随作者学习SpringCloud，
    大体上看了这本书，也是仅仅介绍了各个组件的作用和使用。
    但是比博客上的详细了许多。希望可以学到原理性的东西。

    借此机会，接触docker和中间件相关领域。
    也算是有个方向感吧。
                                                        -2017.12.05 方小白,畅游大厦。
chapter1：
    大体介绍了微服务架构的优缺点及解决方式。
                                                        -2017.12.06 方小白,畅游大厦
chapter2：
    springBoot：
        1.搭建环境，
        2.单元测试。
        3.配置文件。
            多环境配置：application-{profileName}.properties
        4.监控管理：       重点。
            依赖模块spring-boot-starter-actuator，能够自动为Springboot构建的应用提供一系列监控的端点。
            (页面显示401的时候:可能是权限拒绝访问。加上management.security.enabled=false即可)
            actuator中的端点可以按照端点的作用分为三大类：
                应用配置类：获取应用程序中加载的应用配置，环境变量，自动化配置报告等与SpringBoot应用密切相关的配置类信息。
                    /autoconfig：获取应用的自动化配置报告。包括所有自动化配置的候选项。同时还列出了每个候选项是否满足自动化配置的各个先决条件。
                    该报告可以帮助我们方面的找到一些自动化配置为什么没有生效的具体原因。
                    其中：positiveMatches:条件匹配成功的自动化配置。
                          negativeMatches:条件匹配不成功的自动化配置。
                    /beans: 用来获取应用上下文中创建的所用Bean。
                    /configprops：用来获取应用中配置的属性信息报告。
                        prefix：代表了属性配置的前缀。
                        properties：代表了各个属性的名称和值。我们可以通过该报告来看到各个属性的配置路径。
                    /env：用来获取应用所有可用的环境属性报告。环境变量，jvm属性，应用的配置属性，命令行中的参数。
                    /mapping：用来返回所有SpringMVC的控制器映射关系报告.
                    /info: 该端点用来返回一些应用自定义的信息。默认情况下，该断点只会返回一个空的JSON内容。
                        可以在application.properties配置文件中通过info前缀来设置这些属性。
                            info.app.name=Spring-boot-Hello
                度量指标类：获取应用程序运行过程中用于监控的度量指标，比如内存信息，线程池信息,Http请求统计等。
                    动态的数据显示。这些断点提供了应用程序在运行过程中的快照信息，
                    /metrics: 返回当前应用的各类重要度量指标。内存信息，线程信息，垃圾回收信息。
                    /health: 用来获取各类健康指标信息。
                    /dump 用来暴露程序运行中的线程信息。
                    /trace: 用来暴露程序运行中的线程信息

                操作控制类：提供了对应用的关闭等操作类功能。
                    这类端点功能强大，默认不开启。可以通过endpoints.shutdown.enabled=true开启。
           介绍了SpringBoot环境搭建，监控和管理。actuator的各个端点，以及各个端点的作用。
chapter3：
    Spring Cloud Eureka:是Spring Cloud Netflix微服务套件中的一部分，它基于Netflix Eureka做了二次封装，
主要完成微服务架构中的服务治理功能。Spring Cloud通过为Eureka增加了Spring Boot风格的自动化配置，只需引入依赖和注解配置就可以。
    主要内容：构建服务注册中心，服务注册和服务发现，Eureka的基础架构，Eureka的服务治理机制，Eureka的配置。
    Eureka服务端：服务注册中心。
    Eureka客户端：主要处理服务的注册与发现。在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳
      来更新它的服务租约。同时也会从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。

    基础架构：
        服务注册中心：Eureka提供的服务端，提供服务注册与发现的功能。
        服务提供者：提供服务的应用，可以是SpringBoot应用，也可以是其他平台且遵循Eureka通信机制的应用
        服务消费者：消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用所需要的服务。
        **很多时候，客户端既是服务提供者也是服务消费者。

在application.properties或者application.yml中配置对应的实体类:
    eureka.sever.* :EurekaServerConfigBean:  服务服务端 配置类。
    eureka.client.* :EurekaClientConfigBean:  服务客户端 配置类。
    eureka.instance.* : EurekaInstanceConfigBean: 服务 实例配置类。最后会包装成instatInfo发送到服务端。

    (注：出于安全考虑，在配置注册中心的时候，会加入用户名和密码做安全校验.
        http://<username>:<password>@<server.address>:<server.port>/eureka/
    )

    元数据：
        元数据是Eureka客户端向服务之策中心发送注册请求时，用来描述自身服务信息的对象，其中包含了标准化的元数据，比如服务名称，
    实例名称，实例IP、实例端口等，用于服务治理的重要信息；以及用户负载均衡策略或者是其他特殊用途的自定义元数据
        我们可以对eureka.instance.<properties>=<value>的格式对标准化元数据进行直接配置。其中<properties>就是EurekaInstance
    ConfigBean对象中的成员变量名。
    实例名配置：
        实例名，即InstanceInfo中的instanceId参数。它是区分统一服务中不同实例的唯一标识。
    端点配置：
        /heath,/info等。
        如果应用加上了context-path:management.context-path=/hello
        也要为端点加上配置：eureka.instance.statusPageUrlPath=${management.context-path}/info
                           eureka.instance.healthCheckUrlPath=${management.context-path}/health
        有时处于安全考虑也会修改端点路径：
            endpoints.info.path=/appInfo
         则：eureka.instance.statusPageUrlPath=${endpoints.info.path}
         也可以使用绝对路径进行配置：https://{....}

    通信协议：
        Eureka在默认情况下使用：Jersey和XStream配合JSON作为Server和Client之间的通信协议。
            Jersey是JAX-RS的参考实现，它包含三个主要部分。
                核心服务器：通过提供JSR311中标准化的注释和API标准化，可以用直观的方式开发RESTful Web服务。
                核心客户端：Jersey客户端API帮助你与REST服务轻松通信。
                集成：Jersey还可以轻松集成Spring ,Guice,Apache Abdera的库。
            XStream是用来将对象序列化成XML或者反序列化为对象的一个JAVA类库。

                                                                            2017-12-08 方小白,畅游大厦
spring Cloud Ribbon 客户端负载均衡：
    源码分析：
        LoadBalancerClient: 接口。
        其所在的包下\org\springframework\cloud\client\loadbalancer。
        其中：LoadBalancerAutoConfiguration为实现客户端负载均衡器的自动化配置类。
        查看LoadBalancerAutoConfiguration类头上的注解可以知道。Ribbon实现的负载均衡自动化配置需要满足下面的两个条件：
            @ConditionalOnClass(RestTemplate.class) :RestTemplate类必须存在于当前的环境中。
            @ConditionalOnBean(LoadBalancerClient.class)：在Spring的Bean工厂中必须有LoadBalancerClient的实现Bean
        在这个类中主要做了下面三件事：
            1.创建了LoadBalancerInterceptor的Bean，用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡。
            2.创建了RestTemplateCustomizer的Bean，用于给RestTemplate增加LoadBalancerInterceptor拦截器。
            3.维护了RestTemplate的对象列表，并在这里进行初始化，通过调用RestTemplateCustomizer的实例来给需要客户端负载
            均衡的RestTEmpate增加LoadBalancerInterceptor拦截器。

        当一个被LoadBalaced注解修饰的RestTemplate注解修饰的RestTemplate对象向外发起Http请求时，会被LoadBalancerInterceptor类
    的intercept函数所拦截。（在LoadBalancerInterceptor.java中）。由于在调用RestTemplate时，采用了服务名作为host，所以直接
    从HttpRequest的URI对象中通过发送getHost()，就可以拿到服务名，然后调用execute函数去根据服务名来选择实例发起实际的请求。
        查看execute源码，发现在RibbonLoadBalancerClient.java中，对loadBalancer.execute(,)进行了实现。
        首先：根据传入的服务名serviceId通过getServer去获得具体的服务实例。
            注：在进行choose的时候，并不是调用的自己的choose，而是com.netflix.loadbalancer.ILoadBalancer.chooserServer();
           这个接口定义了一个客户端负载均衡器需要的一系列抽象操作。
            对ILoadBalacer接口，BaseLoadBalancer类，实现了基础的负载均衡，而DynamicServerListLoadBalancer和ZoneAwareLoadBalancer
            在负载均衡的策略上做了扩展。
        然后：将其封装成RibbonServer对象，回调LoadBalancerInterceptor请求拦截器中LoadBalancerRequest的apply(final SerivceInstance instance)函数
        向一个实际的具体服务实例发起请求，从而实现host:port形式的实际访问地址的转换。
            在apply函数的实现过程中，封装了ServiceRequestWrapper对象。ServiceRequestWrapper重写了getURI函数。
            重写后的getURI函数，通过调用LoadBalancerClient接口的reconstructURI函数来重新构建一个URI来访问。
            具体的转换过程在RibbonLoadBalancerClient.reconstructURI()中。
            其中RibbonLoadBalancerContext类是LoadBalancerContext的子类，该类用于存储一些被均衡器使用的上下文内容和API操作。
        这个部分主要写了：springCloud 是如何通过LoadBalancerInterceptor拦截器对RestTemplate的请求进行拦截，并利用SpringCloud
        的负载均衡器LoadBalancerClient将以逻辑服务名为host的URI转换成具体的服务实例地址的过程。同时通过分析LoadBalancerClient
        的Ribbon实现RibbonLoadBalancerClient，可以知道在使用Ribbon负载均衡器的时候，实际使用的还是Ribbon定义的ILoaderBalancer接口的实现
        自动化配置会采用ZoneAwareLoadBalancer的实例来实现客户端负载均衡。


    负载均衡器：ILoadBalancer的体系结构。
        SpringCloud定义了LoadBalancerClient作为负载均衡器的通用接口，并且针对Ribbon实现了RibbonLoadBalancerClient，但是
        在具体实现客户端负载均衡的时候，是通过Ribbon的ILoadBalancer接口实现的。
        首先看一个ILoadBalancer接口的抽象实现-AbstractLoadBalancer。
        BaseLoadBalancer是Ribbon负载均衡的基础实现类，在该类中定义了很多关乎负载均衡相关的基础内容。
        两个维护存储服务实例的Server对象的列表。
            @Monitor(name = PREFIX + "AllServerList", type = DataSourceType.INFORMATIONAL)
            protected volatile List<Server> allServerList = Collections.synchronizedList(new ArrayList<Server>());
            @Monitor(name = PREFIX + "UpServerList", type = DataSourceType.INFORMATIONAL)
            protected volatile List<Server> upServerList = Collections.synchronizedList(new ArrayList<Server>());
        用来存储负载均衡器各服务实例舒心个统计信息的LoadBalancerStats对象。
            protected LoadBalancerStats lbStats;
        定义了检查服务实例是否正常服务的IPing对象，在BaseLoadBalancer中默认为null，需要在构造时注入它的具体实例。
            protected IPing ping = null;
        定义了检查服务实例操作的执行策略对象IPingStrategy
            protected IPingStrategy pingStrategy = DEFAULT_PING_STRATEGY;
        定义了负载均衡的处理规则IRule对象。 默认使用RoundRobinRule实现最基本且常用的线性负载均衡规则。

        启动ping任务：在BaseLoadBalancer的默认构造函数中，会直接启动一个用于检查Server是否健康的任务。该任务默认的执行间隔是10秒。

        实现了ILoadBalancer接口定义的负载均衡器,都有以下功能：
            addServers()  : 添加服务
            chooseServer() ： 挑选一个具体的服务实例
            markServerDown() ： 标志某个服务暂停服务。
            getReachableServers()： 获取可用的服务列表
            getAllServers() ： 获取所有的服务实例列表。

    DynamicServerListLoadBalancer:
        在BasicLoadBalancer的基础上，实现了服务实例清单在运行期的动态更新能力。还具备对服务实例清单的过滤功能。
        也就是说可以通过过滤器来选择性的获取一批服务实例清单。


















