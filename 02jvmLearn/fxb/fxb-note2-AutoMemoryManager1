java内存区域域内存溢出异常：
    1.运行时数据区域：
        java虚拟机在执行java程序的过程中会把他缩管的内存划分为若干个不同的数据区域。
        见图 1.java虚拟机运行时数据区。
    1.1  程序计数器：
          作用是：当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
       分支，循环，跳转，异常处理，线程回复等基础功能都需要依赖这个计数器来完成。
        java虚拟机中的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何的一个确定的时刻，一个处理(对于多核处理器来说是一个内核)
        只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。
        我们称这类内存区域为"线程私有"的内存。
            如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
            如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在ajva虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
    1.2  java虚拟机栈
        java虚拟机也是线程私有的，它的生命周期和线程相同。
        虚拟机栈描述的是java方法执行的内存模型：
            每个方法执行的时候都会同时创建一个栈帧(stack Frame)用于存储局部变量表，操作栈，动态链接，方法出口等信息。
            每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
        局部变量表存放了编译期可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double),对象引用和returnAddress类型。
           其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据累心只占用1个。
           局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量是完全确定的，在方法运行期间不会改变局部变量表的大小。
        在java虚拟机规范中：
            如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
            如果虚拟机栈可以动态扩展，当扩展时无法申请足够的内从会抛出OutOfMemoryError异常。
    1.3  本地方法栈：
        本地方法栈与虚拟机栈所发挥的作用非常相似，其区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是为虚拟机使用的Native方法服务。
        有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。
    1.4  堆
        java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
        目的就是存放对象实例。
        java堆是垃圾收集器的主要区域，，很多时候也称为GC堆（garbage collected Heap）。

        根据java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
    1.5  方法区
        方法区和java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
        在方法区中垃圾回收行为是比较少出现的，内存回收目标主要是针对常量池的回收和对类型的卸载。
    1.6  运行时常量池
            运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池
        用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
            运行时常量池相对于Class文件的另外一个重要特征就是具备动态性，java语言并不要求常量一定只能在编译器产生，
        也就是并非预置入Class文件中常量池的内从才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，
        这种特性被开发人员利用的比较多的便是String类的intern()方法。
    1.7     直接内存
        直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但是这部分频繁被调用。
2.对象访问：
    引用类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到java堆中的对象的具体位置。
 主流的访问方式有两种：使用句柄和直接指针。
    如果使用句柄访问方式，java堆中会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
 如图2 通过句柄访问对象
    如果使用直接指针访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。
 如图3 通过直接指针访问对象
    这两种方式的比较：
        1.句柄：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
        2.直接指针：速度更快。它节省了一次指针定位的时间开销，

3. 实战：OutOfMemoryError异常
   目的： 1 通过代码验证java虚拟机规范中描述的各个运行时区域存储的内容。
         2 在工作中遇到内存溢出时，能够异常信息快速判断是哪个区域的内存溢出并且如何处理。
   3.1  java堆溢出
        java堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象。
     就会在对象数量达到最大堆的容量限制后产生内存溢出异常。
        代码演示：demo1.HeapOOM
        提示信息：
              java.lang.OutOfMemoryError: Java heap space
     解决这个区域的异常，一般的手段是首先通过内存映像分析工具对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的。
   也就是要先分清楚到底是出现了内存泄露（memory leak）还是内存溢出(Memory OverFlow)。
        内存泄露：
            通过工具嘻哈看泄漏对象到GCRoots的引用链。找到泄露对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收他们。
        内存溢出：
            检查虚拟机的堆参数(-Xms,-Xmx)与机器屋里内存对比看是否还可以调大，
            从代码上检查是否存在某些对象生命周期过长，持有状态过长的状态，尝试减少程序运行期的内存消耗。
   3.2  虚拟机栈和本地方法栈溢出：
        HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。对HotSpot来说，-Xoss参数(设置本地方法栈大小)虽然存在，但实际上无效。栈容量只能由-Xss参数设定。
     虚拟机栈和本地方法栈，在java虚拟机规范中描述了两种异常：
        如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
           代码演示：demo1.JavaVMStackSOF.java
           在单个线程下，无论是栈帧太大，还是虚拟机栈容量小，当内存无法分配的时候，
            虚拟机抛出的都是StackOverflowError异常、
             如果非单线程的情况下，通过不断建立线程的方式倒是可以产生内存溢出异常。但是 这样产生的内存溢出异常和栈空间是否足够大并不存在任何联系。
            或者准确的说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。
        如果虚拟机栈可以动态扩展，当扩展时无法申请足够的空间从会抛出OutOfMemoryError异常。
            如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。
            见代码 demo1.JavaVMStackOOM.java
                会造成操作系统假死。
    3.3  运行时常量池溢出：
        使用String.intern()这个native方法。
        该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象。
            否则将此String对象包含的字符串添加到常量池中。并且返回此String对象的引用。

        由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。
          见演示代码： demo1.RuntimeConstantPoolOOM.java
          抛出 PermGen space,说明运行时常量池属于方法区（Hotspot虚拟机中的永久代）的一部分。
     3.4 方法区溢出
         方法区用于存储Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。
         基本的思路：运行时产生大量的类去填满方法区，知道溢出。
    3.5  本机直接内存溢出
