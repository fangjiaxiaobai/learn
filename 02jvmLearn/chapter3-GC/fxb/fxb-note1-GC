    Java和C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外的人想进去，墙里的人却想出来。

3.1 概述
    GC需要完成的三件事：
        哪些内存需要回收？
        什么时候回收？
        如何回收？

    为什么要了解GC和内存分配：
        当需要排查各种内存溢出，内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

        由于程序计数器，虚拟机栈，本地方法区的内存分配和回收都具备确定性，所以这几个区域内不需要过多考虑回收的问题。
    方法结束结束或线程结束时，内存自然就回收了。但是，java堆和方法区不同，一个借口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样。
    我们只有在程序处于运行期间才能回创建哪些对象，这部分的内存的分配和回收都是动态的。垃圾收集器锁关注的就是这个部分的内存。

3.2 如何垃圾回收：
    1.对象已死？
        堆中存放了java中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还活着，哪些已经死去（不可能再被任何途径使用的对象）。
    1.1  引用计数法：
            给对象中添加了一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器值就减1,；任何时刻计数器为0的对象就是不可能再被使用的。
         引用计数算法的实现很简单，判定效率也很高，python语言以及游戏脚本中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。
         但是java语言中没有选用计数算法来管理内存。其中最主要的原因是它很难解决对象之间的相互循环引用的问题。
            举一个例子：由于对象之间相互引用而导致其引用计数不为0
                栗子：com.fxb.gc.demo1.Demo1TestGC.java
                看不懂结果是什么意思。
    1.2  根搜索算法：
            通过一些列的名为"GC roots"的对象作为起始点，从这些点节点向下搜索，搜索所有走过的路径称为引用链(Reference chain),
        当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC roots到这个对象不可达)时，则证明此对象是不可用的。
            如图1-根搜索算法

            在java语言里，可作为GC Roots的对象包括以下几种：
                虚拟机栈(栈帧中的本地变量表)中引用的对象。
                方法区中的类静态属性引用的对象。
                方法区中的常量引用的对象
                本地方法栈中JNI(一般说的Native方法)的引用的对象。

    1.3 在谈谈引用：
         这种算法判断对象是否存活都与引用相关，在JDK1.2前，java中的引用的定义很简单，如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
         在这种定义下，一个对象只有被引用或者没有被引用两种状态，但是我们希望能描述这样一类对象，当内存空间还足够时，则能保留在内存之中，如果内存在进行垃圾收集后还是非常紧张，
         则可以抛弃这些对象，
            在jdk1.2之后，java对引用的概念机型了扩充，将引用分为强引用，软引用，弱引用，虚引用四种，这四钟引用强度依次主键减弱。
            强引用就是指在程序代码中普遍存在，类似Object obj = new Object(); 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
            软引用用来描述一些还有用，但并非必须的对象。这类对象，在系统将要发生内存溢出的之前。将会把这些对象列进回收范围之中，并进行第二次回收。
            弱引用：用来描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前
            虚引用:一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。

    1.4  生存还是死亡？
        要真正的宣布一个对象死亡，至少要经历两次标记过程。
            如果对象在进行根搜索后，发现没有与GC roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
            当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为"没有必要执行".(fxb:finalize方法会在对象释放前被调用)
            如果这个对象被判定为有必要执行finalize()方法，那么这个对象会被放置在一个名为F-Queue的队列之中，并在稍后有一条由虚拟机自动建立的，低优先级的Finalizer线程去执行。
            这里所谓的"执行" 是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。原因是如果一个对象在finalize方法中执行缓慢，或者发生了死循环，将很可能会导致
            F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
            finalize()方法是对象逃脱死亡命令的最后一次机会。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己，
            只要重新与引用链上的任何一个对象关联即可，比如把自己复制给某个类变量或者对象的成员变量，那在第二次标记时它将会被移除“即将死亡(回收)”的集合。
            如果对象这时候还没有逃脱，那就真的是离死不远了。
               demo：演示 使用finalize()方法 避免对象回收。

               finalize()能做到的方法，使用try-finally或者其他方式都可以实现，而且更好，更及时，
    1.5  回收方法区：
        永久代就是jvm的方法区：
        永久代的垃圾回收主要回收两部分内容，废弃常量和无用的类。
            判断一个常量是否是一个废弃常量，很简单：如果系统的没有任何一个String对象时叫做abc，也就是说，没有任何String对象应用常量池中的"abc"常量，这个“abc”
             常量就会被请出常量池。常量池中的其他类(接口)，方法，字段的符号引用也与此类似。
            判断一个类是否是一个无用的类，该类要同时满足下面3个条件才能算是“无用的类”
              1. 该类所有的实例都已经被回收，也就是说java堆中不存在该类的任何实例。
              2. 加载该类的ClassLoader都已经被回收。
              3. 该类对应的java.lang.Class对象，没有在任何地方被引用，无法在任何地方通过发射访问该类的方法。
        是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。还可以使用-verbose:class及-XX:+TraceClassLoading,-XX:+TraceClassUnloading查看类的加载和卸载信息。
        -verbose:class和-XX:+TraceClassLoading可以在product版的虚拟机中使用，但是-XX:+TraceClassLoading参数需要在fastdebug版的虚拟机中支持。
3.3   垃圾回收算法
        简单讲解下几种垃圾收集算法。
        1 标记-清除算法：
            思想是：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有标记的对象。
                缺点：效率问题，低。
                    空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前出发领一次垃圾手机动作。
            ** 见图  标记-清楚算法示意图
        2 复制算法：
            为了解决效率问题，一种复制的收集算法出现了。
                它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活的对象复制到另外一块上面，
            然后再把已使用过的内存空间一次清理掉。
                每次回收都是对其中的一块进行内存回收，内存分配是也就不用考虑内存碎片等复杂情况。只需要移动堆顶指针，按顺序分配内存。
              缺点是：将内存缩小为原来的一半。
            现在  商业虚拟机都是用这种收集算法来回收新生代。
                将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象
                一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。
            **见图   复制算法示意图
        3. 标记-整理算法
            根据老年代的特点，产生了标记-整理算法，标记过程仍然与"标记-清除算法"一致，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动。
            然后直接清理掉端边界以外的内存。
            ** 见图   标记-整理算法示意图
        4. 分代收集算法，
            根据对象的存活周期的不同将内存划分为几块。
            一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
3.4   垃圾收集器
        垃圾收集器是内存回收的具体实现。
        Sun HotSpot虚拟机1.6版Update22 包含的收集器，如图3-5 HotSpotJVM1.6的垃圾收集器。
        **看图，如果两个收集器之间存在连线，就说明它们可以搭配使用。
    1.Serial收集器：
        最根本，历史最悠久的收集器。这个一个单线程的收集器。但是它在收集的时候，要把其他所有的线程都停掉。
        见图Serial/SerialOld收集器运行示意图
       但是到目前为止，它仍然是虚拟机运行在Client模式下的默认新生代收集器。毕竟简单而高效。
    2.ParNew收集器，
        其实它是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他和Serial一样。
        **见图ParNew 收集器运行示意图
        是许多Server模式下的虚拟机中首选的新生代收集器。除了性能原因之外，还有一个重要的原因是，目前只有他能和CMS收集器配合工作。
    3. Parallel Scavenge收集器
        新生代收集器，使用复制算法。并行的多线程收集器。。。。
        Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。  即CPU用于运行用户代码的时间和CPU消耗时间的比值。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）

        停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验，而高吞吐量则可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运行而不需要太多交互的任务。
    4. Serial Old收集器。
        Serial收集器是Serial收集器的老年代版本，单线程收集器，使用"标记-整理算法"
        **见图 3-8 Serial old收集器运行示意图。

    5. Parallel Old 收集器
        Parallel Scavenge收集器的老年代版本。使用多线程和"标记-整理"算法。
        **见图3-9 Parallel Old 收集器运行示意图

    6. CMS（concurrent Mark Sweep） 收集器
        以获取最短回收停顿时间为目标的收集器。适合集中在互联网站或者B/S系统的服务端上的应用。
        这类应用尤其重视服务的响应速度，
        使用"标记-清除"算法。
        运行过程比较复杂，整个过程分为4个步骤：
            初始标记：需要stop the world,仅仅是标记GCroots能直接关联到的对象，速度很快，
            并发标记：进行ROots Tracing的过程，
            重新标记：为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。
            并发清除：

        缺点：
            CMS收集器对CPU资源非常敏感。
                在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
                为解决这个缺点，虚拟机提供了一种 增量式并发收集器。就是在并发标记和并发清理的时候让GC线程，用户线程交替运行，尽量减少GC线程的独占资源的时间。
                这样让垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。
                但是该收集器，不提倡使用。
            CMS收集器无法处理浮动垃圾。
                浮动垃圾，出现在并发标记之后的垃圾。
                要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败。这个时间，虚拟机就会
                启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集。
    7. G1收集器：
        1.G1收集器是基于“标记-整理”算法实现的收集器。
        2.它可以非常精确地控制停顿，既能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
        3.G1收集器可以实现在基本不牺牲吞吐量的前提下弯沉低停顿的内存回收，这个是由于他能够极力地避免全区域的垃圾收集。
            G1将整个Java堆(新生代，老年代)划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，
            每次根据允许的收集时间，优先回收垃圾最多的区域。

    垃圾收集器参数总结
        **见表3-1 垃圾收集相关的常用参数。

3.5  内存分配和回收策略(P66)
    java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给对象分配内存以及回收分配给对象的内存。
    对象的分配，往大方向上讲，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，并按线程优先在TLAB上分配。
    少数情况下也可能会直接分配在老年代。分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器，还有虚拟机中与内存相关的参数的设置。

    接下来验证的使用Serial/Serial Old收集器下的内存分配和回收策略。
        先说两个概念：
            新生代GC(Minor GC):指发生在新生代的垃圾收集动作。java对象大多都具有朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。
            老年代GC(Major GC/Full GC):指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次的Minor GC，Major GC 比 Minor GC慢10倍以上。

    1. 对象优先在Eden上分配。
        见demo3

    2. 大对象直接进入老年代
        大对象是指需要连续内存空间的Java对象。
        虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。
        目的是 避免在Eden区及两个Survivor区中发生大量的内存拷贝。
        PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。
        查看使用垃圾收集器：java -XX:+PrintCommandLineFlags -version
        见demo4
    3. 长期存活的对象将进入老年代
        虚拟机给每个对象定义了对象年龄计数器。
        对象在Survivor区中每熬过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（15），就会晋升到老年代中。
        可通过-XX:MaxTenuringThreshold来设置

    4.动态对象年龄判定
        如果在Survivor空间中相同的年龄所有对象大小综合大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。
    5.空间分配担保：








