虚拟机是如何执行定义在Class文件中的字节码的

1.栈帧结构
    栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。
栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息，每个方法从调用开始到执行完毕的过程
就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
    一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
    （在编译期都已经写进了方法表的code属性了）

    一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的
    称为当前栈帧、这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令只针对当前栈帧进行操作。
        栈帧结构如图8-1栈帧的概念结构
    1. 局部变量表：一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。大小在编译的饿时候被写入到Code属性中max_locals
    2. 操作数栈：最大深度在编译时期些人max_stacks
        当一个方法刚刚开始执行的饿时候，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令像操作栈中写入和读取内容，即入栈出栈操作。
    在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机的实现都会做一些优化处理。令两个栈帧出现一部分重叠。让上下两个
    栈帧的部分局部变量表重叠在一起，这样在进行方法调用的时候可以用用一部分数据，无须尽心额外的参数复制传递。
        java虚拟机的解释执行引擎称为基于栈的执行引擎。其中所指的栈就是操作数栈。
    3. 动态链接：
    4. 方法返回地址：
        方法退出有两种方法：遇到一个方法返回的字节码指令，返回上层方法调用者。正常完成出口。
        在方法执行过程中遇到了异常，并在方法中没有处理。异常完成出口，它不会给它的上层调用者产生任何返回值。

2.方法调用
    这个步骤就是确定被调用方法的版本。还不涉及方法内部的具体运行过程。
    1.解析：
         符合编译期可知，运行期不变这个要求的方法主要有静态方法和私有方法两大类。它们不可能被继承或者重写。因此适合在类加载阶段解析。
         jvm有四种指令：
            invokestatic：调用静态方法。
            invokevirtual: 调用虚方法，final方法
            invokespecial: 调用构造方法，私有方法，父方法
            invokeinterface:调用接口方法
         解析是一个静态的过程，在编译器就能完全确定，在类装载的解析阶段就会把设计的符号引用给全部转换为可确定的直接引用。
    2.分派Dispacher：
        动态的过程。
        静态分派：
            所有依赖静态类型来定位方法执行版本的分派动态，都称为静态分派。
            静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

            典型例子：重载。
        动态分派：
            重写。

3.基于栈的字节码解释执行引擎
    程序代码到物理机的目标代码或者虚拟机能执行的指令集之前，都需要经过图8-4编译过程的各个步骤




