第七章   虚拟机类加载机制
代码编译的结果从本地机器码变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

    A 类加载的时机
    B 类加载的过程
    C 类加载器


1.
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，
这就是虚拟机的类加载机制。
    java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。
    语言上的约定：助于理解：
        第一：在实际情况中，每个Class文件都有可能代表着java语言中的一个类或者接口，后文中至直接对类的描述都包括了类和接口的可能性，
    而对于类和接口需要分开描述的差劲会特别指明，
        第二：Class文件并非指Class必须是存在于具体磁盘的某个文件，这里说的class文件是指一串二进制的字节流，无论以何种形式存在都可以。

2.类加载的时机：
        类从被加载到虚拟机内存中开始，到出内存外为止，它的生命周期包括了加载，验证，准备，解析，初始化，使用，卸载七个阶段。
    如图7-1 类的生命周期

        加载，验证，准备，初始化和卸载这个五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班开始，而解析阶段则不一定。
    它在某些情况下可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或者晚期绑定).这些阶段通常都是在
    互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

    2.1 加载
        虚拟机规范中并没有进行强制约束。这点可以交给虚拟机的具体实现来自由把握。但是虚拟机规范对初始化阶段严格规定了有且只有四钟情况必须立即对类
    进行初始化，(加载，验证，准备，自然要在此之前开始)
        1.遇到new，getstatic，putstatic,或者invokestatic这4条字节码指令时，如果类没有进行过初始胡啊，则需要先触发其初始化。
    常见场景为：new，读取或者设置一个类的静态字段(被final修饰，已在编译期结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方式的时候，
        2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
        3.初始化一个类的时候，如果发现父类还没有进行初始化，则需要先触发其父类的初始化。
        4.当虚拟机启动的时候，用户需要指定一个要执行的主类，虚拟机会先初始化这个类。
    只有这个四种场景称为对一个类进行主动引用。除此之外所有引用类的方式，都不会触发初始化，称为被动引用。
    被动引用的场景：
        1.通过子类引用父类的静态变量：com.fxb.classLoading.demo1.Demo1.java
            只会触发父类的初始化，不会触发子类的初始化。至于是否会触发子类的加载和验证，在虚拟机规范中没有明确规定。
        2.通过数组定义来引用类，不会触发此类的初始化：com.fxb.classLoading.demo1.Demo2.java
        3.常量在编译阶段会存入调用类的常量池中，本质上没有直接引用定义常量的类，因为不会触发定义常量的类初始化。
           虽然在java源码中引用ConstClass类中的常量HelloWorld,但是在编译阶段将此常量的值Hello world存储到了Demo类的常量池中。
        对于ConstClass.HELLOWORLD的引用实际都转化为Demo类对自身常量池的应用了.

3. 类加载的过程
    1.加载：
        虚拟机需要完成三件事：
            1.通过一个类的全限定名来获取定义此类的二进制流。
            2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
            3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
        相对类加载的其他阶段，加载阶段(准确的说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段既可以使用
    系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。
        加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。然后再Java堆中实例化一个java.lang.Class类的对象
    这个对象作为程序访问方法区中的这些类型数据的外部接口。加载阶段和连接阶段的部分内容时交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。
    但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

    2.验证：
        验证是连接阶段的第一步，目的是：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
        不同的虚拟机会有不同的验证过程，但是大体上都会进行如下四个阶段：
            1.文件格式的验证：
        是否以魔数开头，主次版本号是否在当前虚拟机处理范围之内。。。。
        保证输入的字节流能够解析并保存在方法区之内。格式上符合描述一个java类型信息的要求格式上符合描述一个java类型信息的要求
           2.元数据验证
           对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。
            3. 字节码验证：
           主要是进行数据流和控制流分析。对类的方法体进行校验分析。保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。
           4.符号引用验证
            对类自身以外的信息进行匹配性的校验。目的是保证解析动作能正确执行。
    3.准备
        准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区中进行分配。
        比如 private static int value = 123;
       在这个时期value的值是0。赋值123发生在初始化阶段。
    4.解析
        解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
        符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
        直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者是一个能直接定位到目标的句柄。

        解析动作主要针对类或接口，字段，类方法，接口方法四类符号引用进行，分别对应常量池中CNSTANT_Class_info，CONSTANT_Methodref_info及
    CONSTANT_Fieldref_info,CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量类型。
    5.初始化
        初始化是类加载过程的最后一步。
4.类加载器：
        虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己去决定所需要的类。
    实现这个动作的代码模块被称为“类加载器”。
        双亲委派模型：
            在java虚拟机的角度，只有两种不同的类加载器，启动类加载器，由c++编写，是java虚拟机的一部分。另一种是所有其他的类加载器，由java语言实现，独立于虚拟机外部。
         并且全部集成自抽象类java.lang.ClassLoader.
            在java开发人员的角度，可分为：
            启动类加载器：加载JAVA_HOME\lib中。或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的类库。
            扩展类加载器：负责加载JAVA_HOME\lib\ext中或者被java.ext.dirs系统变量所指定的路径中的所有类库。
            应用程序类加载器：系统类加载器，加载用户类路径上指定的类型。
            如图三种类加载器之间的关系。

        工作过程是：
            如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，二十把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此、
        因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载、










